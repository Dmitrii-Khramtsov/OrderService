
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Dmitrii-Khramtsov/orderservice/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/Dmitrii-Khramtsov/orderservice/internal/application/order_service.go (0.0%)</option>
				
				<option value="file2">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/app.go (0.0%)</option>
				
				<option value="file3">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/cache.go (0.0%)</option>
				
				<option value="file4">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/database.go (0.0%)</option>
				
				<option value="file5">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/kafka.go (0.0%)</option>
				
				<option value="file6">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/logger.go (0.0%)</option>
				
				<option value="file7">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/server.go (0.0%)</option>
				
				<option value="file8">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/lifecycle.go (0.0%)</option>
				
				<option value="file9">github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/migrator.go (0.0%)</option>
				
				<option value="file10">github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities/item.go (0.0%)</option>
				
				<option value="file11">github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities/order.go (0.0%)</option>
				
				<option value="file12">github.com/Dmitrii-Khramtsov/orderservice/internal/domain/repositories/repository.go (0.0%)</option>
				
				<option value="file13">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/cache/order_cache_lru.go (93.1%)</option>
				
				<option value="file14">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config/config.go (0.0%)</option>
				
				<option value="file15">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database/postgres_repository.go (68.2%)</option>
				
				<option value="file16">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database/retrying_repository.go (53.3%)</option>
				
				<option value="file17">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/kafka/consumer.go (0.0%)</option>
				
				<option value="file18">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger/logger.go (0.0%)</option>
				
				<option value="file19">github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/migrations/migrations.go (0.0%)</option>
				
				<option value="file20">github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/handler/order_handler.go (0.0%)</option>
				
				<option value="file21">github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/router/router.go (0.0%)</option>
				
				<option value="file22">github.com/Dmitrii-Khramtsov/orderservice/scripts/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/cmd/server/main.go
package main

import (
        "context"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/joho/godotenv"
        _ "github.com/lib/pq"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap"
)

        func main() <span class="cov0" title="0">{
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to load .env file: %v", err)
        }</span>

        <span class="cov0" title="0">app, err := bootstrap.NewApp()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">app.Run()

        quit := make(chan os.Signal, 1)
        signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
        &lt;-quit

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        app.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/application/order_service.go
package application

import (
        "context"
        "fmt"
        "time"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/cache"
        repository "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
        "go.uber.org/zap"
)

type OrderServiceInterface interface {
        SaveOrder(ctx context.Context, order entities.Order) (OrderResult, error)
        GetOrder(ctx context.Context, id string) (entities.Order, error)
        GetAllOrder(ctx context.Context) ([]entities.Order, error)
        DelOrder(ctx context.Context, id string) error
        ClearOrder(ctx context.Context) error
        GetAllFromDB(ctx context.Context) ([]entities.Order, error)
}

type orderService struct {
        cache  cache.Cache
        logger logger.LoggerInterface
        repo   repository.OrderRepository
        getAllLimit int
}

func NewOrderService(c cache.Cache, l logger.LoggerInterface, r repository.OrderRepository, limit int) OrderServiceInterface <span class="cov0" title="0">{
        return &amp;orderService{
                cache:  c,
                logger: l,
                repo:   r,
                getAllLimit: limit,
        }
}</span>

type OrderResult string

const (
        OrderCreated OrderResult = "created"
        OrderUpdated OrderResult = "updated"
        OrderExists  OrderResult = "exists"
)

func (s *orderService) SaveOrder(ctx context.Context, order entities.Order) (OrderResult, error) <span class="cov0" title="0">{
        startTime := time.Now()
        defer s.logSaveDuration(order.OrderUID, startTime)

        if err := s.validateOrder(order); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">result := s.determineOrderResult(order)

        if err := s.saveToRepo(ctx, order); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">s.updateCache(order, result)

        return result, nil</span>
}

func (s *orderService) validateOrder(order entities.Order) error <span class="cov0" title="0">{
        if err := order.Validate(); err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("order validation failed",
                        zap.String("order_id", order.OrderUID),
                        zap.Error(err),
                )
                return fmt.Errorf("%w: %v", domain.ErrInvalidOrder, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *orderService) determineOrderResult(order entities.Order) OrderResult <span class="cov0" title="0">{
        existing, found := s.cache.Get(order.OrderUID)
        switch </span>{
        case !found:<span class="cov0" title="0">
                return OrderCreated</span>
        case existing.Equal(order):<span class="cov0" title="0">
                return OrderExists</span>
        default:<span class="cov0" title="0">
                return OrderUpdated</span>
        }
}

func (s *orderService) saveToRepo(ctx context.Context, order entities.Order) error <span class="cov0" title="0">{
        if err := s.repo.SaveOrder(ctx, order); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to save order to db",
                        zap.String("order_id", order.OrderUID),
                        zap.Error(err),
                )
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *orderService) updateCache(order entities.Order, result OrderResult) <span class="cov0" title="0">{
        s.cache.Set(order.OrderUID, order)
        s.logger.Info("order saved",
                zap.String("order_id", order.OrderUID),
                zap.String("result", string(result)),
        )
}</span>

func (s *orderService) logSaveDuration(orderID string, startTime time.Time) <span class="cov0" title="0">{
        s.logger.Info("SaveOrder completed",
                zap.String("order_id", orderID),
                zap.Duration("duration", time.Since(startTime)),
        )
}</span>

func (s *orderService) GetOrder(ctx context.Context, id string) (entities.Order, error) <span class="cov0" title="0">{
        if order, found := s.cache.Get(id); found </span><span class="cov0" title="0">{
                s.logger.Info("order retrieved from cache", zap.String("order_id", id))
                return order, nil
        }</span>

        <span class="cov0" title="0">dbOrder, err := s.fetchFromRepo(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Warn("order not found in db",
                        zap.String("order_id", id),
                        zap.Error(err),
                )
                return entities.Order{}, domain.ErrOrderNotFound
        }</span>

        <span class="cov0" title="0">s.cache.Set(dbOrder.OrderUID, dbOrder)
        s.logger.Info("order retrieved from db and cached", zap.String("order_id", id))
        return dbOrder, nil</span>
}

func (s *orderService) fetchFromRepo(ctx context.Context, id string) (entities.Order, error) <span class="cov0" title="0">{
        order, err := s.repo.GetOrder(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return entities.Order{}, err
        }</span>
        <span class="cov0" title="0">return order, nil</span>
}

func (s *orderService) DelOrder(ctx context.Context, id string) error <span class="cov0" title="0">{
        if err := s.repo.DeleteOrder(ctx, id); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to delete order from db",
                        zap.String("order_id", id),
                        zap.Error(err),
                )
                return err
        }</span>

        <span class="cov0" title="0">ok := s.cache.Delete(id)
        if !ok </span><span class="cov0" title="0">{
                s.logger.Warn("order not found in cache", zap.String("order_id", id))
        }</span>

        <span class="cov0" title="0">s.logger.Info("order deleted", zap.String("order_id", id))
        return nil</span>
}

func (s *orderService) ClearOrder(ctx context.Context) error <span class="cov0" title="0">{
        s.cache.Clear()

        if err := s.repo.ClearOrders(ctx); err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to clear orders from db", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">s.logger.Info("all orders cleared")
        return nil</span>
}

func (s *orderService) GetAllOrder(ctx context.Context) ([]entities.Order, error) <span class="cov0" title="0">{
        orders, err := s.cache.GetAll(s.getAllLimit)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to retrieve orders from cache", zap.Error(err))
                return nil, fmt.Errorf("failed to retrieve orders from cache: %w", err)
        }</span>
        <span class="cov0" title="0">s.logger.Info("retrieved all orders from cache", zap.Int("count", len(orders)))
        return orders, err</span>
}

func (s *orderService) GetAllFromDB(ctx context.Context) ([]entities.Order, error) <span class="cov0" title="0">{
        return s.repo.GetAllOrders(ctx)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/app.go
package bootstrap

import (
        "context"
        "net/http"

        "github.com/jmoiron/sqlx"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/application"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/cache"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config"
        repo "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/kafka"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/handler"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/router"
)

type Shutdownable interface {
        Shutdown(ctx context.Context) error
}

type DBWrapper struct {
        DB *sqlx.DB
}

func (dw *DBWrapper) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return dw.DB.Close()
}</span>

type App struct {
        Server        *http.Server
        Logger        logger.LoggerInterface
        Cache         cache.Cache
        Repo          repo.OrderRepository
        Service       application.OrderServiceInterface
        Handler       *handler.OrderHandler
        KafkaConsumer kafka.ConsumerInterface
        DB            Shutdownable
}

func NewApp() (*App, error) <span class="cov0" title="0">{
        cfg, err := config.LoadConfig("config.yml")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">l, err := factory.NewLogger(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">c := factory.NewCache(l, cfg.Cache.Capacity)
        db, err := factory.NewDatabase(cfg, l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := RunMigrations(context.Background(), db, cfg.Migrations.MigrationsPath, l, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rp, err := factory.NewOrderRepository(cfg, db, l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">svc := application.NewOrderService(c, l, rp, cfg.Cache.GetAllLimit)

        h := handler.NewOrderHandler(svc, l)
        r := router.New(h)
        srv := factory.NewHTTPServer(cfg.Server.Port, r)

        kc := factory.NewKafkaConsumer(cfg.Kafka, svc, l)

        return &amp;App{
                Server:        srv,
                Logger:        l,
                Cache:         c,
                Repo:          rp,
                Service:       svc,
                Handler:       h,
                KafkaConsumer: kc,
                DB:            &amp;DBWrapper{DB: db},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/cache.go
package factory

import (
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/cache"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

func NewCache(l logger.LoggerInterface, capacity int) cache.Cache <span class="cov0" title="0">{
        return cache.NewOrderLRUCache(l, capacity)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/database.go
// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/database.go
package factory

import (
        "fmt"

        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config"
        repo "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

func NewDatabase(cfg *config.Config, l logger.LoggerInterface) (*sqlx.DB, error) <span class="cov0" title="0">{
        db, err := sqlx.Connect("postgres", cfg.Database.DSN)
        if err != nil </span><span class="cov0" title="0">{
                l.Error("failed to connect to db", zap.Error(err))
                return nil, fmt.Errorf("%w: %v", repo.ErrDatabaseConnectionFailed, err)
        }</span>

        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.Database.MaxOpenConns)
        db.SetMaxIdleConns(cfg.Database.MaxIdleConns)
        db.SetConnMaxLifetime(cfg.Database.ConnMaxLifetime)

        return db, nil</span>
}

func NewOrderRepository(cfg *config.Config, db *sqlx.DB, l logger.LoggerInterface) (repo.OrderRepository, error) <span class="cov0" title="0">{
        baseRepo, err := repo.NewPostgresOrderRepository(db, l)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">retryConfig := &amp;repo.RetryConfig{
                MaxElapsedTime:      cfg.Retry.MaxElapsedTime,
                InitialInterval:     cfg.Retry.InitialInterval,
                RandomizationFactor: cfg.Retry.RandomizationFactor,
                Multiplier:          cfg.Retry.Multiplier,
                MaxInterval:         cfg.Retry.MaxInterval,
        }

        return repo.NewRetryingOrderRepository(baseRepo, l, retryConfig), nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/kafka.go
package factory

import (
        "time"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/application"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/kafka"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

func NewKafkaConsumer(cfg config.KafkaConfig, svc application.OrderServiceInterface, l logger.LoggerInterface) kafka.ConsumerInterface <span class="cov0" title="0">{
        retryConfig := &amp;kafka.RetryConfig{
                InitialInterval:    time.Second,
                Multiplier:         2,
                MaxInterval:        30 * time.Second,
                MaxElapsedTime:     5 * time.Minute,
                RandomizationFactor: 0.5,
        }

        return kafka.NewConsumer(
                cfg.Brokers,
                cfg.Topic,
                cfg.GroupID,
                cfg.DLQTopic,
                svc,
                l,
                retryConfig,
                cfg.MaxRetries,
        )
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/logger.go
package factory

import (
        "os"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

func NewLogger(cfg *config.Config) (logger.LoggerInterface, error) <span class="cov0" title="0">{
        mode := logger.DEV
        if envLogMode := os.Getenv("LOG_MODE"); envLogMode == "production" </span><span class="cov0" title="0">{
                mode = logger.PROD
        }</span>
        <span class="cov0" title="0">return logger.NewLogger(mode)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/factory/server.go
package factory

import (
        "net/http"

        "github.com/go-chi/chi/v5"
)

func NewHTTPServer(port string, r *chi.Mux) *http.Server <span class="cov0" title="0">{
        return &amp;http.Server{
                Addr:    ":" + port,
                Handler: r,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/lifecycle.go
package bootstrap

import (
        "context"
        "net/http"

        "go.uber.org/zap"
)

func (a *App) Run() <span class="cov0" title="0">{
        a.Logger.Info("server starting", zap.String("addr", a.Server.Addr))
        a.KafkaConsumer.Start()

        go a.restoreCacheFromDB(context.Background())

        go func() </span><span class="cov0" title="0">{
                if err := a.Server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        a.Logger.Error("server listen failed", zap.Error(err))
                }</span>
        }()
}

func (a *App) Shutdown(ctx context.Context) <span class="cov0" title="0">{
        a.Logger.Info("shutdown initiated")

        if err := a.KafkaConsumer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("failed to shutdown kafka consumer", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := a.Server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("server forced to shutdown", zap.Error(err))
        }</span>

        <span class="cov0" title="0">resources := []struct {
                name string
                res  Shutdownable
        }{
                {"cache", a.Cache},
                {"logger", a.Logger},
                {"repository", a.Repo},
                {"database", a.DB},
        }

        for _, resource := range resources </span><span class="cov0" title="0">{
                if resource.res == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err := resource.res.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        a.Logger.Error("failed to shutdown resource",
                                zap.String("resource", resource.name),
                                zap.Error(err),
                        )
                }</span> else<span class="cov0" title="0"> {
                        a.Logger.Info("resource stopped gracefully",
                                zap.String("resource", resource.name),
                        )
                }</span>
        }

        <span class="cov0" title="0">a.Logger.Info("shutdown completed")</span>
}

// восстановление кеша из БД
func (a *App) restoreCacheFromDB(ctx context.Context) <span class="cov0" title="0">{
        orders, err := a.Service.GetAllFromDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Error("failed to restore cache from DB", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">for _, o := range orders </span><span class="cov0" title="0">{
                a.Cache.Set(o.OrderUID, o)
        }</span>

        <span class="cov0" title="0">a.Logger.Info("cache restored from DB", zap.Int("count", len(orders)))</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/bootstrap/migrator.go
package bootstrap

import (
        "context"

        "github.com/cenkalti/backoff/v4"
        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/migrations"
)

func RunMigrations(ctx context.Context, db *sqlx.DB, migrationsPath string, l logger.LoggerInterface, cfg *config.Config) error <span class="cov0" title="0">{
        operation := func() error </span><span class="cov0" title="0">{
                return migrations.RunMigrations(ctx, db.DB, migrationsPath, l)
        }</span>

        <span class="cov0" title="0">retryPolicy := backoff.NewExponentialBackOff()
        retryPolicy.MaxElapsedTime = cfg.Retry.MaxElapsedTime

        if err := backoff.Retry(operation, retryPolicy); err != nil </span><span class="cov0" title="0">{
                l.Error("failed to run migrations after retries", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">l.Info("migrations completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities/item.go
package entities

type Item struct {
        ChrtID      int    `json:"chrt_id" db:"chrt_id"`
        TrackNumber string `json:"track_number" db:"track_number"`
        Price       int    `json:"price" db:"price"`
        RID         string `json:"rid" db:"rid"`
        Name        string `json:"name" db:"name"`
        Sale        int    `json:"sale" db:"sale"`
        Size        string `json:"size" db:"size"`
        TotalPrice  int    `json:"total_price" db:"total_price"`
        NmID        int    `json:"nm_id" db:"nm_id"`
        Brand       string `json:"brand" db:"brand"`
        Status      int    `json:"status" db:"status"`
}

func (i *Item) Equal(other Item) bool <span class="cov0" title="0">{
        return i.ChrtID == other.ChrtID &amp;&amp;
                     i.TrackNumber == other.TrackNumber &amp;&amp;
                     i.Price == other.Price &amp;&amp;
                     i.RID == other.RID &amp;&amp;
                     i.Name == other.Name &amp;&amp;
                     i.Sale == other.Sale &amp;&amp;
                     i.Size == other.Size &amp;&amp;
                     i.TotalPrice == other.TotalPrice &amp;&amp;
                     i.NmID == other.NmID &amp;&amp;
                     i.Brand == other.Brand &amp;&amp;
                     i.Status == other.Status
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities/order.go
package entities

import "strings"

type Order struct {
        OrderUID        string   `json:"order_uid" db:"order_uid"`
        TrackNumber     string   `json:"track_number" db:"track_number"`
        Entry           string   `json:"entry" db:"entry"`
        Delivery        Delivery `json:"delivery"`
        Payment         Payment  `json:"payment"`
        Items           []Item   `json:"items"`
        Locale          string   `json:"locale" db:"locale"`
        InternalSig     string   `json:"internal_signature" db:"internal_signature"`
        CustomerID      string   `json:"customer_id" db:"customer_id"`
        DeliveryService string   `json:"delivery_service" db:"delivery_service"`
        ShardKey        string   `json:"shardkey" db:"shardkey"`
        SMID            int      `json:"sm_id" db:"sm_id"`
        DateCreated     string   `json:"date_created" db:"date_created"`
        OOFShard        string   `json:"oof_shard" db:"oof_shard"`
}

func (o *Order) Equal(other Order) bool <span class="cov0" title="0">{
        return o.basicFieldsEqual(other) &amp;&amp;
                o.deliveryEqual(other) &amp;&amp;
                o.paymentEqual(other) &amp;&amp;
                o.itemsEqual(other)
}</span>

func (o *Order) basicFieldsEqual(other Order) bool <span class="cov0" title="0">{
        return o.OrderUID == other.OrderUID &amp;&amp;
                o.TrackNumber == other.TrackNumber &amp;&amp;
                o.Entry == other.Entry &amp;&amp;
                o.Locale == other.Locale &amp;&amp;
                o.InternalSig == other.InternalSig &amp;&amp;
                o.CustomerID == other.CustomerID &amp;&amp;
                o.ShardKey == other.ShardKey &amp;&amp;
                o.SMID == other.SMID &amp;&amp;
                o.DateCreated == other.DateCreated &amp;&amp;
                o.OOFShard == other.OOFShard
}</span>

func (o *Order) deliveryEqual(other Order) bool <span class="cov0" title="0">{
        return o.Delivery.Name == other.Delivery.Name &amp;&amp;
                o.Delivery.Phone == other.Delivery.Phone &amp;&amp;
                o.Delivery.Zip == other.Delivery.Zip &amp;&amp;
                o.Delivery.City == other.Delivery.City &amp;&amp;
                o.Delivery.Address == other.Delivery.Address &amp;&amp;
                o.Delivery.Region == other.Delivery.Region &amp;&amp;
                o.Delivery.Email == other.Delivery.Email
}</span>

func (o *Order) paymentEqual(other Order) bool <span class="cov0" title="0">{
        return o.Payment.Transaction == other.Payment.Transaction &amp;&amp;
                o.Payment.RequestID == other.Payment.RequestID &amp;&amp;
                o.Payment.Currency == other.Payment.Currency &amp;&amp;
                o.Payment.Provider == other.Payment.Provider &amp;&amp;
                o.Payment.Amount == other.Payment.Amount &amp;&amp;
                o.Payment.PaymentDT == other.Payment.PaymentDT &amp;&amp;
                o.Payment.Bank == other.Payment.Bank &amp;&amp;
                o.Payment.DeliveryCost == other.Payment.DeliveryCost &amp;&amp;
                o.Payment.GoodsTotal == other.Payment.GoodsTotal &amp;&amp;
                o.Payment.CustomFee == other.Payment.CustomFee
}</span>

func (o *Order) itemsEqual(other Order) bool <span class="cov0" title="0">{
        if len(o.Items) != len(other.Items) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">for i := range o.Items </span><span class="cov0" title="0">{
                if !o.Items[i].Equal(other.Items[i]) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (o Order) Validate() error <span class="cov0" title="0">{
        switch </span>{
        case o.OrderUID == "":<span class="cov0" title="0">
                return ErrOrderUIDRequired</span>
        case o.TrackNumber == "":<span class="cov0" title="0">
                return ErrTrackNumberRequired</span>
        case len(o.Items) == 0:<span class="cov0" title="0">
                return ErrItemsEmpty</span>
        case o.Payment.Amount &lt; 0:<span class="cov0" title="0">
                return ErrInvalidPaymentAmount</span>
        case o.Delivery.Email != "" &amp;&amp; !strings.Contains(o.Delivery.Email, "@"):<span class="cov0" title="0">
                return ErrInvalidEmailFormat</span>
        case o.Delivery.Phone != "" &amp;&amp; !strings.HasPrefix(o.Delivery.Phone, "+"):<span class="cov0" title="0">
                return ErrInvalidPhoneFormat</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/repositories/entities
package repositories

import "database/sql"

type OrderRepository struct {
        db *sql.DB
}

func NewOrderRepository(db *sql.DB) *OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository {
                db: db,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/cache/order_cache_lru.go
package cache

import (
        "container/list"
        "context"
        "sync"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
        "go.uber.org/zap"
)

type entry struct {
        key   string
        value entities.Order
}

type orderLRUCache struct {
        sync.RWMutex
        capacity int
        cache    map[string]*list.Element
        ll       *list.List
        logger   logger.LoggerInterface
}

func NewOrderLRUCache(l logger.LoggerInterface, capacity int) Cache <span class="cov5" title="14">{
        if capacity &lt;= 0 </span><span class="cov1" title="1">{
                capacity = -1
                l.Info("cache capacity is set to unlimited")
        }</span>
        <span class="cov5" title="14">return &amp;orderLRUCache{
                capacity: capacity,
                cache:    make(map[string]*list.Element, max(0, capacity)),
                ll:       list.New(),
                logger:   l,
        }</span>
}

func (c *orderLRUCache) Set(orderID string, order entities.Order) <span class="cov10" title="124">{
        c.RWMutex.Lock()
        defer c.RWMutex.Unlock()

        if elem, exist := c.cache[orderID]; exist </span><span class="cov2" title="2">{
                entry := elem.Value.(*entry)
                entry.value = order
                c.ll.MoveToFront(elem)
                c.logger.Debug("order updated in cache", zap.String("order_id", orderID))
                return
        }</span>

        <span class="cov9" title="122">if c.capacity &gt; 0 &amp;&amp; c.ll.Len() &gt;= c.capacity </span><span class="cov3" title="3">{
                lastElem := c.ll.Back()
                if lastElem != nil </span><span class="cov3" title="3">{
                        lastEntry := lastElem.Value.(*entry)
                        delete(c.cache, lastEntry.key)
                        c.ll.Remove(lastElem)
                        c.logger.Debug("cache exceeded, most unused order deleted", zap.String("order_id", lastEntry.key))
                }</span>
        }

        <span class="cov9" title="122">newEntry := &amp;entry{key: orderID, value: order}
        newElem := c.ll.PushFront(newEntry)
        c.cache[orderID] = newElem</span>
}

func (c *orderLRUCache) Get(orderID string) (entities.Order, bool) <span class="cov9" title="121">{
        c.Lock()
        defer c.Unlock()

        elem, exist := c.cache[orderID]
        if !exist </span><span class="cov4" title="8">{
                c.logger.Debug("there is no such order", zap.String("order_id", orderID))
                return entities.Order{}, false
        }</span>

        <span class="cov9" title="113">c.ll.MoveToFront(elem)
        entry := elem.Value.(*entry)
        c.logger.Debug("retrieved order from cache", zap.String("order_id", orderID))
        return entry.value, true</span>
}

func (c *orderLRUCache) GetAll(limit int) ([]entities.Order, error) <span class="cov2" title="2">{
        c.RWMutex.RLock()
        defer c.RWMutex.RUnlock()

        if limit &lt;= 0 </span><span class="cov0" title="0">{
                c.logger.Debug("limit is less than or equal to zero, returning empty slice", zap.Int("limit", limit))
                return []entities.Order{}, nil
        }</span>

        <span class="cov2" title="2">capacity := limit
        if len(c.cache) &lt; limit </span><span class="cov1" title="1">{
                capacity = len(c.cache)
                c.logger.Debug("limit exceeds cache size, adjusting capacity",
                        zap.Int("limit", limit),
                        zap.Int("cache_size", len(c.cache)),
                        zap.Int("adjusted_capacity", capacity))
        }</span>

        <span class="cov2" title="2">orders := make([]entities.Order, 0, capacity)
        count := 0
        for elem := c.ll.Front(); elem != nil &amp;&amp; count &lt; limit; elem = elem.Next() </span><span class="cov3" title="4">{
                entry := elem.Value.(*entry)
                orders = append(orders, entry.value)
                count++
        }</span>

        <span class="cov2" title="2">c.logger.Debug("Retrieved orders from cache",
                zap.Int("requested_limit", limit),
                zap.Int("returned_count", count))

        return orders, nil</span>
}

func (c *orderLRUCache) Delete(orderID string) bool <span class="cov1" title="1">{
        c.RWMutex.Lock()
        defer c.RWMutex.Unlock()

        if elem, exist := c.cache[orderID]; exist </span><span class="cov1" title="1">{
                c.ll.Remove(elem)
                delete(c.cache, orderID)
                c.logger.Info("order deleted", zap.String("order_id", orderID))
                return true
        }</span>

        <span class="cov0" title="0">c.logger.Info("order not deleted", zap.String("order_id", orderID))
        return false</span>
}

func (c *orderLRUCache) reset() <span class="cov2" title="2">{
        cacheCapacity := c.capacity
        if cacheCapacity &lt;= 0 </span><span class="cov0" title="0">{
                cacheCapacity = 0
        }</span>
        <span class="cov2" title="2">c.cache = make(map[string]*list.Element, cacheCapacity)
        c.ll.Init()</span>
}

func (c *orderLRUCache) Clear() <span class="cov1" title="1">{
        c.RWMutex.Lock()
        defer c.RWMutex.Unlock()
        c.reset()
        c.logger.Info("cache cleared")
}</span>

func (c *orderLRUCache) Shutdown(ctx context.Context) error <span class="cov1" title="1">{
        c.RWMutex.Lock()
        defer c.RWMutex.Unlock()
        c.reset()
        c.logger.Info("cache cleared during shutdown")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/config/config.go
package config

import (
        "time"

        "github.com/spf13/viper"
)

type CacheConfig struct {
        Capacity    int `mapstructure:"capacity"`
        GetAllLimit int `mapstructure:"get_all_limit"`
}

type DatabaseConfig struct {
        DSN             string        `mapstructure:"dsn"`
        MaxOpenConns    int           `mapstructure:"max_open_conns"`
        MaxIdleConns    int           `mapstructure:"max_idle_conns"`
        ConnMaxLifetime time.Duration `mapstructure:"conn_max_lifetime"`
}

type KafkaConfig struct {
        Brokers    []string `mapstructure:"brokers"`
        Topic      string   `mapstructure:"topic"`
        GroupID    string   `mapstructure:"group_id"`
        DLQTopic   string   `mapstructure:"dlq_topic"`
        MaxRetries int      `mapstructure:"max_retries"`
}

type ServerConfig struct {
        Port string `mapstructure:"port"`
}

type MigrationsConfig struct {
        MigrationsPath string `mapstructure:"migrations_path"`
}

type RetryConfig struct {
        MaxElapsedTime      time.Duration `mapstructure:"max_elapsed_time"`
        InitialInterval     time.Duration `mapstructure:"initial_interval"`
        RandomizationFactor float64       `mapstructure:"randomization_factor"`
        Multiplier          float64       `mapstructure:"multiplier"`
        MaxInterval         time.Duration `mapstructure:"max_interval"`
}

type Config struct {
        Cache      CacheConfig      `mapstructure:"cache"`
        Database   DatabaseConfig   `mapstructure:"database"`
        Kafka      KafkaConfig      `mapstructure:"kafka"`
        Server     ServerConfig     `mapstructure:"server"`
        Migrations MigrationsConfig `mapstructure:"migrations"`
        Retry      RetryConfig      `mapstructure:"retry"`
}

func LoadConfig(path string) (*Config, error) <span class="cov0" title="0">{
        viper.SetConfigFile(path)

        viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">viper.BindEnv("database.dsn", "POSTGRES_DSN")
        viper.BindEnv("kafka.brokers", "KAFKA_BROKERS")
        viper.BindEnv("log.mode", "LOG_MODE")

        var cfg Config
        if err := viper.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database/postgres_repository.go
package repository

import (
        "context"
        "database/sql"
        "errors"
        "fmt"

        "github.com/jmoiron/sqlx"
        "go.uber.org/zap"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

type PostgresOrderRepository struct {
        db     *sqlx.DB
        logger logger.LoggerInterface
}

func NewPostgresOrderRepository(db *sqlx.DB, logger logger.LoggerInterface) (*PostgresOrderRepository, error) <span class="cov1" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return nil, errors.New("db is nil")
        }</span>
        <span class="cov1" title="1">return &amp;PostgresOrderRepository{db: db, logger: logger}, nil</span>
}

func (r *PostgresOrderRepository) SaveOrder(ctx context.Context, order entities.Order) error <span class="cov10" title="5">{
        tx, err := r.db.BeginTxx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrTransactionFailed, err)
        }</span>
        <span class="cov10" title="5">defer tx.Rollback()

        if err := r.saveOrder(ctx, tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="5">if err := r.saveDelivery(ctx, tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="5">if err := r.savePayment(ctx, tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="5">if err := r.saveItems(ctx, tx, order); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov10" title="5">return tx.Commit()</span>
}

func (r *PostgresOrderRepository) saveOrder(ctx context.Context, tx *sqlx.Tx, order entities.Order) error <span class="cov10" title="5">{
        query := `
                INSERT INTO orders (
                        order_uid, track_number, entry, locale, internal_signature,
                        customer_id, delivery_service, shardkey, sm_id, date_created, oof_shard
                ) VALUES (
                        :order_uid, :track_number, :entry, :locale, :internal_signature,
                        :customer_id, :delivery_service, :shardkey, :sm_id, :date_created, :oof_shard
                ) ON CONFLICT (order_uid) DO UPDATE SET
                        track_number = EXCLUDED.track_number,
                        entry = EXCLUDED.entry,
                        locale = EXCLUDED.locale,
                        internal_signature = EXCLUDED.internal_signature,
                        customer_id = EXCLUDED.customer_id,
                        delivery_service = EXCLUDED.delivery_service,
                        shardkey = EXCLUDED.shardkey,
                        sm_id = EXCLUDED.sm_id,
                        date_created = EXCLUDED.date_created,
                        oof_shard = EXCLUDED.oof_shard
        `

        _, err := tx.NamedExecContext(ctx, query, order)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to save order", zap.Error(err), zap.String("order_uid", order.OrderUID))
                return fmt.Errorf("%w: %v", ErrOrderSaveFailed, err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

func (r *PostgresOrderRepository) saveDelivery(ctx context.Context, tx *sqlx.Tx, order entities.Order) error <span class="cov10" title="5">{
        query := `
                INSERT INTO delivery (
                        order_uid, name, phone, zip, city, address, region, email
                ) VALUES (
                        :order_uid, :name, :phone, :zip, :city, :address, :region, :email
                ) ON CONFLICT (order_uid) DO UPDATE SET
                        name = EXCLUDED.name,
                        phone = EXCLUDED.phone,
                        zip = EXCLUDED.zip,
                        city = EXCLUDED.city,
                        address = EXCLUDED.address,
                        region = EXCLUDED.region,
                        email = EXCLUDED.email
        `

        deliveryMap := map[string]interface{}{
                "order_uid": order.OrderUID,
                "name":      order.Delivery.Name,
                "phone":     order.Delivery.Phone,
                "zip":       order.Delivery.Zip,
                "city":      order.Delivery.City,
                "address":   order.Delivery.Address,
                "region":    order.Delivery.Region,
                "email":     order.Delivery.Email,
        }

        _, err := tx.NamedExecContext(ctx, query, deliveryMap)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to save delivery", zap.Error(err), zap.String("order_uid", order.OrderUID))
                return fmt.Errorf("%w: %v", ErrOrderSaveFailed, err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

func (r *PostgresOrderRepository) savePayment(ctx context.Context, tx *sqlx.Tx, order entities.Order) error <span class="cov10" title="5">{
        query := `
                INSERT INTO payment (
                        order_uid, transaction, request_id, currency, provider,
                        amount, payment_dt, bank, delivery_cost, goods_total, custom_fee
                ) VALUES (
                        :order_uid, :transaction, :request_id, :currency, :provider,
                        :amount, :payment_dt, :bank, :delivery_cost, :goods_total, :custom_fee
                ) ON CONFLICT (order_uid) DO UPDATE SET
                        transaction = EXCLUDED.transaction,
                        request_id = EXCLUDED.request_id,
                        currency = EXCLUDED.currency,
                        provider = EXCLUDED.provider,
                        amount = EXCLUDED.amount,
                        payment_dt = EXCLUDED.payment_dt,
                        bank = EXCLUDED.bank,
                        delivery_cost = EXCLUDED.delivery_cost,
                        goods_total = EXCLUDED.goods_total,
                        custom_fee = EXCLUDED.custom_fee
        `

        paymentMap := map[string]interface{}{
                "order_uid":     order.OrderUID,
                "transaction":   order.Payment.Transaction,
                "request_id":    order.Payment.RequestID,
                "currency":      order.Payment.Currency,
                "provider":      order.Payment.Provider,
                "amount":        order.Payment.Amount,
                "payment_dt":    order.Payment.PaymentDT,
                "bank":          order.Payment.Bank,
                "delivery_cost": order.Payment.DeliveryCost,
                "goods_total":   order.Payment.GoodsTotal,
                "custom_fee":    order.Payment.CustomFee,
        }

        _, err := tx.NamedExecContext(ctx, query, paymentMap)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to save payment", zap.Error(err), zap.String("order_uid", order.OrderUID))
                return fmt.Errorf("%w: %v", ErrOrderSaveFailed, err)
        }</span>

        <span class="cov10" title="5">return nil</span>
}

func (r *PostgresOrderRepository) saveItems(ctx context.Context, tx *sqlx.Tx, order entities.Order) error <span class="cov10" title="5">{
        // First delete existing items
        deleteQuery := "DELETE FROM items WHERE order_uid = $1"
        _, err := tx.ExecContext(ctx, deleteQuery, order.OrderUID)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to delete existing items", zap.Error(err), zap.String("order_uid", order.OrderUID))
                return fmt.Errorf("%w: %v", ErrOrderSaveFailed, err)
        }</span>

        // Insert new items
        <span class="cov10" title="5">query := `
                INSERT INTO items (
                        chrt_id, order_uid, track_number, price, rid, name,
                        sale, size, total_price, nm_id, brand, status
                ) VALUES (
                        :chrt_id, :order_uid, :track_number, :price, :rid, :name,
                        :sale, :size, :total_price, :nm_id, :brand, :status
                )
        `

        for _, item := range order.Items </span><span class="cov10" title="5">{
                itemMap := map[string]interface{}{
                        "chrt_id":      item.ChrtID,
                        "order_uid":    order.OrderUID,
                        "track_number": item.TrackNumber,
                        "price":        item.Price,
                        "rid":          item.RID,
                        "name":         item.Name,
                        "sale":         item.Sale,
                        "size":         item.Size,
                        "total_price":  item.TotalPrice,
                        "nm_id":        item.NmID,
                        "brand":        item.Brand,
                        "status":       item.Status,
                }

                _, err := tx.NamedExecContext(ctx, query, itemMap)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("failed to save item", zap.Error(err), zap.String("order_uid", order.OrderUID))
                        return fmt.Errorf("%w: %v", ErrOrderSaveFailed, err)
                }</span>
        }

        <span class="cov10" title="5">return nil</span>
}

func (r *PostgresOrderRepository) GetOrder(ctx context.Context, id string) (entities.Order, error) <span class="cov10" title="5">{
        query := `
                SELECT 
                        o.*,
                        d.name, d.phone, d.zip, d.city, d.address, d.region, d.email,
                        p.transaction, p.request_id, p.currency, p.provider, p.amount,
                        p.payment_dt, p.bank, p.delivery_cost, p.goods_total, p.custom_fee,
                        i.chrt_id, i.track_number, i.price, i.rid, i.name as item_name,
                        i.sale, i.size, i.total_price, i.nm_id, i.brand, i.status
                FROM orders o
                LEFT JOIN delivery d ON o.order_uid = d.order_uid
                LEFT JOIN payment p ON o.order_uid = p.order_uid
                LEFT JOIN items i ON o.order_uid = i.order_uid
                WHERE o.order_uid = $1
        `

        rows, err := r.db.QueryxContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return entities.Order{}, ErrOrderNotFound
                }</span>
                <span class="cov0" title="0">r.logger.Error("failed to get order", zap.Error(err), zap.String("order_uid", id))
                return entities.Order{}, fmt.Errorf("%w: %v", ErrQueryFailed, err)</span>
        }
        <span class="cov10" title="5">defer rows.Close()

        var order entities.Order
        var items []entities.Item

        for rows.Next() </span><span class="cov7" title="3">{
                var item entities.Item
                var delivery entities.Delivery
                var payment entities.Payment

                err := rows.Scan(
                        &amp;order.OrderUID, &amp;order.TrackNumber, &amp;order.Entry, &amp;order.Locale,
                        &amp;order.InternalSig, &amp;order.CustomerID, &amp;order.DeliveryService,
                        &amp;order.ShardKey, &amp;order.SMID, &amp;order.DateCreated, &amp;order.OOFShard,
                        &amp;delivery.Name, &amp;delivery.Phone, &amp;delivery.Zip, &amp;delivery.City,
                        &amp;delivery.Address, &amp;delivery.Region, &amp;delivery.Email,
                        &amp;payment.Transaction, &amp;payment.RequestID, &amp;payment.Currency,
                        &amp;payment.Provider, &amp;payment.Amount, &amp;payment.PaymentDT, &amp;payment.Bank,
                        &amp;payment.DeliveryCost, &amp;payment.GoodsTotal, &amp;payment.CustomFee,
                        &amp;item.ChrtID, &amp;item.TrackNumber, &amp;item.Price, &amp;item.RID, &amp;item.Name,
                        &amp;item.Sale, &amp;item.Size, &amp;item.TotalPrice, &amp;item.NmID, &amp;item.Brand, &amp;item.Status,
                )

                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("failed to scan order", zap.Error(err), zap.String("order_uid", id))
                        return entities.Order{}, fmt.Errorf("%w: %v", ErrQueryFailed, err)
                }</span>

                <span class="cov7" title="3">order.Delivery = delivery
                order.Payment = payment
                items = append(items, item)</span>
        }

        <span class="cov10" title="5">if order.OrderUID == "" </span><span class="cov4" title="2">{
                return entities.Order{}, ErrOrderNotFound
        }</span>

        <span class="cov7" title="3">order.Items = items
        return order, nil</span>
}

func (r *PostgresOrderRepository) GetAllOrders(ctx context.Context) ([]entities.Order, error) <span class="cov4" title="2">{
        query := "SELECT order_uid FROM orders"
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to get all orders", zap.Error(err))
                return nil, fmt.Errorf("%w: %v", ErrQueryFailed, err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        var orders []entities.Order
        for rows.Next() </span><span class="cov1" title="1">{
                var orderUID string
                if err := rows.Scan(&amp;orderUID); err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("failed to scan order uid", zap.Error(err))
                        continue</span>
                }

                <span class="cov1" title="1">order, err := r.GetOrder(ctx, orderUID)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Error("failed to get order details", zap.Error(err), zap.String("order_uid", orderUID))
                        continue</span>
                }

                <span class="cov1" title="1">orders = append(orders, order)</span>
        }

        <span class="cov4" title="2">return orders, nil</span>
}

func (r *PostgresOrderRepository) DeleteOrder(ctx context.Context, id string) error <span class="cov1" title="1">{
        query := "DELETE FROM orders WHERE order_uid = $1"
        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to delete order", zap.Error(err), zap.String("order_uid", id))
                return fmt.Errorf("%w: %v", ErrOrderDeleteFailed, err)
        }</span>

        <span class="cov1" title="1">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: %v", ErrOrderDeleteFailed, err)
        }</span>

        <span class="cov1" title="1">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrOrderNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

func (r *PostgresOrderRepository) ClearOrders(ctx context.Context) error <span class="cov1" title="1">{
        query := "DELETE FROM orders"
        _, err := r.db.ExecContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("failed to clear orders", zap.Error(err))
                return fmt.Errorf("%w: %v", ErrOrderClearFailed, err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

func (r *PostgresOrderRepository) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return r.db.Close()
}</pre>
		
		<pre class="file" id="file16" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/database/retrying_repository.go
package repository

import (
        "context"
        "time"

        "github.com/cenkalti/backoff/v4"
        "go.uber.org/zap"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

type RetryingOrderRepository struct {
        repo   OrderRepository
        logger logger.LoggerInterface
        config *RetryConfig
}

type RetryConfig struct {
        MaxElapsedTime     time.Duration
        InitialInterval    time.Duration
        RandomizationFactor float64
        Multiplier         float64
        MaxInterval        time.Duration
}

func NewRetryingOrderRepository(repo OrderRepository, logger logger.LoggerInterface, config *RetryConfig) *RetryingOrderRepository <span class="cov5" title="5">{
        return &amp;RetryingOrderRepository{
                repo:   repo,
                logger: logger,
                config: config,
        }
}</span>

func (r *RetryingOrderRepository) withRetry(ctx context.Context, operation func() error) error <span class="cov5" title="5">{
        expBackoff := backoff.NewExponentialBackOff()
        expBackoff.MaxElapsedTime = r.config.MaxElapsedTime
        expBackoff.InitialInterval = r.config.InitialInterval
        expBackoff.RandomizationFactor = r.config.RandomizationFactor
        expBackoff.Multiplier = r.config.Multiplier
        expBackoff.MaxInterval = r.config.MaxInterval

        return backoff.Retry(func() error </span><span class="cov10" title="23">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return backoff.Permanent(ctx.Err())</span>
                default:<span class="cov10" title="23">
                        return operation()</span>
                }
        }, expBackoff)
}

func (r *RetryingOrderRepository) SaveOrder(ctx context.Context, order entities.Order) error <span class="cov4" title="4">{
        return r.withRetry(ctx, func() error </span><span class="cov9" title="21">{
                err := r.repo.SaveOrder(ctx, order)
                if err != nil </span><span class="cov9" title="19">{
                        r.logger.Warn("failed to save order, retrying",
                                zap.String("order_uid", order.OrderUID),
                                zap.Error(err),
                        )
                }</span>
                <span class="cov9" title="21">return err</span>
        })
}

func (r *RetryingOrderRepository) GetOrder(ctx context.Context, id string) (entities.Order, error) <span class="cov1" title="1">{
        var order entities.Order
        var err error

        operation := func() error </span><span class="cov2" title="2">{
                order, err = r.repo.GetOrder(ctx, id)
                if err != nil </span><span class="cov1" title="1">{
                        r.logger.Warn("failed to get order, retrying",
                                zap.String("order_uid", id),
                                zap.Error(err),
                        )
                }</span>
                <span class="cov2" title="2">return err</span>
        }

        <span class="cov1" title="1">err = r.withRetry(ctx, operation)
        return order, err</span>
}

func (r *RetryingOrderRepository) GetAllOrders(ctx context.Context) ([]entities.Order, error) <span class="cov0" title="0">{
        var orders []entities.Order
        var err error

        operation := func() error </span><span class="cov0" title="0">{
                orders, err = r.repo.GetAllOrders(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Warn("failed to get all orders, retrying", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err = r.withRetry(ctx, operation)
        return orders, err</span>
}

func (r *RetryingOrderRepository) DeleteOrder(ctx context.Context, id string) error <span class="cov0" title="0">{
        return r.withRetry(ctx, func() error </span><span class="cov0" title="0">{
                err := r.repo.DeleteOrder(ctx, id)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Warn("failed to delete order, retrying",
                                zap.String("order_uid", id),
                                zap.Error(err),
                        )
                }</span>
                <span class="cov0" title="0">return err</span>
        })
}

func (r *RetryingOrderRepository) ClearOrders(ctx context.Context) error <span class="cov0" title="0">{
        return r.withRetry(ctx, func() error </span><span class="cov0" title="0">{
                err := r.repo.ClearOrders(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.Warn("failed to clear orders, retrying", zap.Error(err))
                }</span>
                <span class="cov0" title="0">return err</span>
        })
}

func (r *RetryingOrderRepository) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        return r.repo.Shutdown(ctx)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/kafka/consumer.go
package kafka

import (
        "context"
        "encoding/json"
        "sync"
        "time"

        "github.com/cenkalti/backoff/v4"
        "github.com/segmentio/kafka-go"
        "go.uber.org/zap"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/application"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
)

type Consumer struct {
        reader        *kafka.Reader
        dlqWriter     *kafka.Writer
        svc           application.OrderServiceInterface
        logger        logger.LoggerInterface
        ctx           context.Context
        cancel        context.CancelFunc
        wg            sync.WaitGroup
        retryConfig   *RetryConfig
        maxRetries    int
}

type RetryConfig struct {
        InitialInterval    time.Duration
        Multiplier         float64
        MaxInterval        time.Duration
        MaxElapsedTime     time.Duration
        RandomizationFactor float64
}

func NewConsumer(
        brokers []string,
        topic string,
        groupID string,
        dlqTopic string,
        svc application.OrderServiceInterface,
        l logger.LoggerInterface,
        retryConfig *RetryConfig,
        maxRetries int,
) ConsumerInterface <span class="cov0" title="0">{
        reader := kafka.NewReader(kafka.ReaderConfig{
                Brokers:     brokers,
                Topic:       topic,
                GroupID:     groupID,
                StartOffset: kafka.FirstOffset,
                MinBytes:    10e3,
                MaxBytes:    10e6,
        })

        dlqWriter := &amp;kafka.Writer{
                Addr:     kafka.TCP(brokers...),
                Topic:    dlqTopic,
                Balancer: &amp;kafka.LeastBytes{},
        }

        ctx, cancel := context.WithCancel(context.Background())

        return &amp;Consumer{
                reader:      reader,
                dlqWriter:   dlqWriter,
                svc:         svc,
                logger:      l,
                ctx:         ctx,
                cancel:      cancel,
                retryConfig: retryConfig,
                maxRetries:  maxRetries,
        }
}</span>

func (c *Consumer) Start() <span class="cov0" title="0">{
        c.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer c.wg.Done()
                c.consumeLoop()
        }</span>()
}

func (c *Consumer) consumeLoop() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-c.ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        msg, err := c.reader.FetchMessage(c.ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if c.ctx.Err() != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">c.logger.Error("failed to fetch message", zap.Error(err))
                                time.Sleep(time.Second)
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := c.processWithRetry(msg); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("failed to process message after retries, sending to DLQ",
                                        zap.String("topic", c.reader.Config().Topic),
                                        zap.ByteString("key", msg.Key),
                                        zap.Error(err),
                                )

                                if err := c.sendToDLQ(msg); err != nil </span><span class="cov0" title="0">{
                                        c.logger.Error("failed to send message to DLQ",
                                                zap.ByteString("key", msg.Key),
                                                zap.Error(err),
                                        )
                                }</span>
                        }

                        <span class="cov0" title="0">if err := c.reader.CommitMessages(c.ctx, msg); err != nil </span><span class="cov0" title="0">{
                                c.logger.Error("failed to commit message",
                                        zap.ByteString("key", msg.Key),
                                        zap.Error(err),
                                )
                        }</span>
                }
        }
}

func (c *Consumer) processWithRetry(msg kafka.Message) error <span class="cov0" title="0">{
        expBackoff := backoff.NewExponentialBackOff()
        expBackoff.InitialInterval = c.retryConfig.InitialInterval
        expBackoff.Multiplier = c.retryConfig.Multiplier
        expBackoff.MaxInterval = c.retryConfig.MaxInterval
        expBackoff.MaxElapsedTime = c.retryConfig.MaxElapsedTime
        expBackoff.RandomizationFactor = c.retryConfig.RandomizationFactor

        var lastErr error
        retries := 0

        operation := func() error </span><span class="cov0" title="0">{
                retries++
                order, err := c.decodeOrder(msg.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return backoff.Permanent(err)
                }</span>

                <span class="cov0" title="0">_, err = c.svc.SaveOrder(c.ctx, order)
                if err != nil </span><span class="cov0" title="0">{
                        lastErr = err
                        c.logger.Warn("failed to process message, retrying",
                                zap.String("order_uid", order.OrderUID),
                                zap.Int("attempt", retries),
                                zap.Error(err),
                        )
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">err := backoff.Retry(operation, expBackoff)
        if err != nil &amp;&amp; retries &gt;= c.maxRetries </span><span class="cov0" title="0">{
                return lastErr
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *Consumer) decodeOrder(data []byte) (entities.Order, error) <span class="cov0" title="0">{
        var order entities.Order
        err := json.Unmarshal(data, &amp;order)
        return order, err
}</span>

func (c *Consumer) sendToDLQ(msg kafka.Message) error <span class="cov0" title="0">{
        return c.dlqWriter.WriteMessages(c.ctx, kafka.Message{
                Key:   msg.Key,
                Value: msg.Value,
                Time:  msg.Time,
        })
}</span>

func (c *Consumer) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        c.logger.Info("kafka consumer shutting down...")
        c.cancel()

        if err := c.reader.Close(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to close kafka reader", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if err := c.dlqWriter.Close(); err != nil </span><span class="cov0" title="0">{
                c.logger.Error("failed to close DLQ writer", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                c.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                c.logger.Info("kafka consumer stopped gracefully")
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                c.logger.Warn("kafka consumer shutdown timed out")
                return ctx.Err()</span>
        }
}</pre>
		
		<pre class="file" id="file18" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger/logger.go
package logger

import (
        "context"
        "errors"

        "go.uber.org/zap"
)

type LoggerInterface interface {
        Debug(msg string, fields ...zap.Field)
        Info(msg string, fields ...zap.Field)
        Warn(msg string, fields ...zap.Field)
        Error(msg string, fields ...zap.Field)
        Sync()
        Shutdown(ctx context.Context) error
}

type Logger struct {
        zap *zap.Logger
}

type mode string

const (
        DEV  mode = "development"
        PROD mode = "production"
)

var ErrLoggerInit = errors.New("failed to initialize logger")

func NewLogger(m mode) (LoggerInterface, error) <span class="cov0" title="0">{
        var z *zap.Logger
        var err error

        switch m </span>{
        case DEV:<span class="cov0" title="0">
                z, err = zap.NewDevelopment()</span>
        case PROD:<span class="cov0" title="0">
                z, err = zap.NewProduction()</span>
        default:<span class="cov0" title="0">
                z, err = zap.NewDevelopment()</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, ErrLoggerInit
        }</span>

        <span class="cov0" title="0">return &amp;Logger{zap: z}, nil</span>
}

func (l *Logger) Debug(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Debug(msg, fields...)
}</span>

func (l *Logger) Info(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Info(msg, fields...)
}</span>

func (l *Logger) Warn(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Warn(msg, fields...)
}</span>

func (l *Logger) Error(msg string, fields ...zap.Field) <span class="cov0" title="0">{
        l.zap.Error(msg, fields...)
}</span>

func (l *Logger) Sync() <span class="cov0" title="0">{
        l.zap.Sync()
}</span>

func (l *Logger) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        if err := l.zap.Sync(); err != nil </span><span class="cov0" title="0">{
                l.zap.Error("logger sync failed", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/migrations/migrations.go
package migrations

import (
        "context"
        "database/sql"
        "github.com/golang-migrate/migrate/v4"
        "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
        "go.uber.org/zap"
)

// контекст не участвует, оставлен для консистентности
func RunMigrations(ctx context.Context, db *sql.DB, migrationsPath string, l logger.LoggerInterface) error <span class="cov0" title="0">{
        driver, err := postgres.WithInstance(db, &amp;postgres.Config{})
        if err != nil </span><span class="cov0" title="0">{
                l.Error("failed to create migration driver", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">m, err := migrate.NewWithDatabaseInstance(
                "file://"+migrationsPath,
                "postgres", driver)
        if err != nil </span><span class="cov0" title="0">{
                l.Error("failed to create migration instance", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange </span><span class="cov0" title="0">{
                l.Error("failed to apply migrations", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">l.Info("migrations applied successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/handler/order_handler.go
package handler

import (
        "encoding/json"
        "errors"
        "net/http"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/application"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/Dmitrii-Khramtsov/orderservice/internal/infrastructure/logger"
        httperrors "github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http"
        "github.com/go-chi/chi/v5"
        "go.uber.org/zap"
)

type OrderHandler struct {
        svc    application.OrderServiceInterface
        logger logger.LoggerInterface
}

func NewOrderHandler(s application.OrderServiceInterface, l logger.LoggerInterface) *OrderHandler <span class="cov0" title="0">{
        return &amp;OrderHandler{
                svc:    s,
                logger: l,
        }
}</span>

func writeJSON(w http.ResponseWriter, l logger.LoggerInterface, status int, v any) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(v); err != nil </span><span class="cov0" title="0">{
                l.Error("failed to encode JSON response", zap.Error(err))
                http.Error(w, `{"error": "`+httperrors.ErrJSONEncodeFailed.Error()+`"}`, http.StatusInternalServerError)
        }</span>
}

func (h *OrderHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        order, err := h.decodeOrderRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.handleDecodeError(w, err)
                return
        }</span>

        <span class="cov0" title="0">result, err := h.svc.SaveOrder(ctx, order)
        if err != nil </span><span class="cov0" title="0">{
                h.handleServiceError(w, err)
                return
        }</span>

        <span class="cov0" title="0">h.logger.Info("order saved successfully", zap.String("order_id", order.OrderUID), zap.String("result", string(result)))
        h.writeSuccessResponse(w, order.OrderUID, string(result))</span>
}

func (h *OrderHandler) decodeOrderRequest(r *http.Request) (entities.Order, error) <span class="cov0" title="0">{
        var order entities.Order
        if err := json.NewDecoder(r.Body).Decode(&amp;order); err != nil </span><span class="cov0" title="0">{
                return entities.Order{}, err
        }</span>
        <span class="cov0" title="0">return order, nil</span>
}

func (h *OrderHandler) handleDecodeError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        h.logger.Warn("failed to decode order request",
                zap.Error(err),
                zap.String("error_type", httperrors.ErrInvalidJSON.Error()),
        )
        writeJSON(w, h.logger, http.StatusBadRequest, map[string]string{"error": httperrors.ErrInvalidJSON.Error()})
}</span>

func (h *OrderHandler) handleServiceError(w http.ResponseWriter, err error) <span class="cov0" title="0">{
        if errors.Is(err, domain.ErrInvalidOrder) </span><span class="cov0" title="0">{
                h.logger.Warn("invalid order data", zap.Error(err))
                writeJSON(w, h.logger, http.StatusBadRequest, map[string]string{"error": err.Error()})
        }</span> else<span class="cov0" title="0"> {
                h.logger.Error("failed to save order", zap.Error(err))
                writeJSON(w, h.logger, http.StatusInternalServerError, map[string]string{"error": "internal server error"})
        }</span>
}

func (h *OrderHandler) writeSuccessResponse(w http.ResponseWriter, orderID, result string) <span class="cov0" title="0">{
        writeJSON(w, h.logger, http.StatusOK, map[string]string{
                "order_id": orderID,
                "result":   result,
        })
}</span>

func (h *OrderHandler) GetByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := chi.URLParam(r, "id")
        order, err := h.svc.GetOrder(ctx, id)
        if errors.Is(err, domain.ErrOrderNotFound) </span><span class="cov0" title="0">{
                writeJSON(w, h.logger, http.StatusNotFound, map[string]string{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">h.logger.Info("order retrieved successfully", zap.String("order_id", id))
        writeJSON(w, h.logger, http.StatusOK, order)</span>
}

func (h *OrderHandler) GetAll(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        orders, err := h.svc.GetAllOrder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get all orders", zap.Error(err))
                writeJSON(w, h.logger, http.StatusInternalServerError, map[string]string{"error": "failed to get all orders"})
                return
        }</span>
        <span class="cov0" title="0">h.logger.Info("orders retrieved successfully", zap.Int("count", len(orders)))
        writeJSON(w, h.logger, http.StatusOK, orders)</span>
}

func (h *OrderHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id := chi.URLParam(r, "id")
        err := h.svc.DelOrder(ctx, id)
        if errors.Is(err, domain.ErrOrderNotFound) </span><span class="cov0" title="0">{
                writeJSON(w, h.logger, http.StatusNotFound, map[string]string{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">h.logger.Info("order deleted successfully", zap.String("order_id", id))
        writeJSON(w, h.logger, http.StatusOK, map[string]string{"status": "deleted", "order_id": id})</span>
}

func (h *OrderHandler) Clear(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        if err := h.svc.ClearOrder(ctx); err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to clear orders", zap.Error(err))
                writeJSON(w, h.logger, http.StatusInternalServerError, map[string]string{"error": "failed to clear orders"})
                return
        }</span>
        <span class="cov0" title="0">h.logger.Info("all orders cleared")
        writeJSON(w, h.logger, http.StatusOK, map[string]string{"status": "cleared"})</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/handler/router.go
package router

import (
    "net/http"
    "github.com/go-chi/chi/v5"
    "github.com/Dmitrii-Khramtsov/orderservice/internal/interface/http/handler"
)

func New(h *handler.OrderHandler) *chi.Mux <span class="cov0" title="0">{
    r := chi.NewRouter()
    r.Post("/orders", h.Create)
    r.Get("/orders/{id}", h.GetByID)
    r.Get("/orders", h.GetAll)
    r.Delete("/orders/{id}", h.Delete)
    r.Delete("/orders", h.Clear)

    fs := http.FileServer(http.Dir("./web"))
    r.Handle("/*", fs)
    return r
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// github.com/Dmitrii-Khramtsov/orderservice/scripts/main.go
package main

import (
        "context"
        "encoding/json"
        "log"
        "math/rand"
        "net"
        "os"
        "strconv"
        "time"

        "github.com/Dmitrii-Khramtsov/orderservice/internal/domain/entities"
        "github.com/google/uuid"
        "github.com/joho/godotenv"
        "github.com/segmentio/kafka-go"
)

func generateRandomString(length int) string <span class="cov0" title="0">{
        const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        b := make([]byte, length)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = charset[rand.Intn(len(charset))]
        }</span>
        <span class="cov0" title="0">return string(b)</span>
}

func generateRandomOrderItem() entities.Item <span class="cov0" title="0">{
        return entities.Item{
                ChrtID:      rand.Intn(10000000),
                Name:        "Product_" + generateRandomString(5),
                TrackNumber: "TRACK_" + generateRandomString(10),
                Price:       rand.Intn(1000) + 100,
                RID:         uuid.New().String(),
                Sale:        rand.Intn(50),
                Size:        generateRandomString(3),
                TotalPrice:  rand.Intn(1000) + 100,
                NmID:        rand.Intn(1000000),
                Brand:       "Brand_" + generateRandomString(5),
                Status:      rand.Intn(5),
        }
}</span>

func generateRandomOrder() entities.Order <span class="cov0" title="0">{
        return entities.Order{
                OrderUID:        uuid.New().String(),
                TrackNumber:     "WBILMTESTTRACK_" + generateRandomString(5),
                Entry:           uuid.New().String(),
                Locale:          "en",
                InternalSig:     uuid.New().String(),
                CustomerID:      "customer_" + generateRandomString(8),
                DeliveryService: "delivery_service_" + generateRandomString(5),
                ShardKey:        generateRandomString(5),
                SMID:            rand.Intn(100),
                DateCreated:     time.Now().Format(time.RFC3339),
                OOFShard:        generateRandomString(5),
                Delivery: entities.Delivery{
                        Name:    "Customer " + generateRandomString(5),
                        Phone:   "+" + generateRandomString(10),
                        Zip:     generateRandomString(6),
                        City:    "City_" + generateRandomString(5),
                        Address: "Address_" + generateRandomString(10),
                        Region:  "Region_" + generateRandomString(5),
                        Email:   generateRandomString(5) + "@example.com",
                },
                Payment: entities.Payment{
                        Transaction:  uuid.New().String(),
                        RequestID:    uuid.New().String(),
                        Currency:     "USD",
                        Provider:     "payment_provider_" + generateRandomString(5),
                        Amount:       rand.Intn(1000) + 100,
                        PaymentDT:    time.Now().Unix(),
                        Bank:         "Bank_" + generateRandomString(5),
                        DeliveryCost: rand.Intn(100),
                        GoodsTotal:   rand.Intn(1000) + 100,
                        CustomFee:    rand.Intn(50),
                },
                Items: []entities.Item{
                        generateRandomOrderItem(),
                        generateRandomOrderItem(),
                },
        }
}</span>

func sendOrderToKafka(writer *kafka.Writer, order entities.Order) error <span class="cov0" title="0">{
        messageValue, err := json.Marshal(order)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return writer.WriteMessages(context.Background(), kafka.Message{
                Key:   []byte(order.OrderUID),
                Value: messageValue,
        })</span>
}

func main() <span class="cov0" title="0">{
        // Загружаем .env
        if err := godotenv.Load(".env"); err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: failed to load .env file: %v", err)
        }</span>

        // Получаем адрес Kafka-брокера
        <span class="cov0" title="0">brokerAddress := os.Getenv("KAFKA_BROKERS")
        if brokerAddress == "" </span><span class="cov0" title="0">{
                log.Fatal("Kafka broker address is not set in .env")
        }</span>

        <span class="cov0" title="0">topic := os.Getenv("KAFKA_TOPIC")
        if topic == "" </span><span class="cov0" title="0">{
                topic = "orders"
        }</span>

        <span class="cov0" title="0">numMessages, _ := strconv.Atoi(os.Getenv("NUMBER_OF_MESSAGES"))
        if numMessages &lt;= 0 </span><span class="cov0" title="0">{
                numMessages = 10
        }</span>

        <span class="cov0" title="0">delayMs, _ := strconv.Atoi(os.Getenv("DELAY_MS"))
        if delayMs &lt;= 0 </span><span class="cov0" title="0">{
                delayMs = 500
        }</span>

        <span class="cov0" title="0">log.Printf("Using Kafka broker: %s", brokerAddress)
        log.Printf("Using Kafka topic: %s", topic)

        // Создаём топик, если его нет
        conn, err := kafka.Dial("tcp", brokerAddress)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to Kafka: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        controller, err := conn.Controller()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get controller: %v", err)
        }</span>

        <span class="cov0" title="0">controllerConn, err := kafka.Dial("tcp", net.JoinHostPort(controller.Host, strconv.Itoa(controller.Port)))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to controller: %v", err)
        }</span>
        <span class="cov0" title="0">defer controllerConn.Close()

        _ = controllerConn.CreateTopics(kafka.TopicConfig{
                Topic:             topic,
                NumPartitions:     1,
                ReplicationFactor: 1,
        })

        // Создаём Kafka Writer
        writer := kafka.NewWriter(kafka.WriterConfig{
                Brokers:  []string{brokerAddress},
                Topic:    topic,
                Balancer: &amp;kafka.LeastBytes{},
        })
        defer writer.Close()

        // Отправляем сообщения
        for i := 0; i &lt; numMessages; i++ </span><span class="cov0" title="0">{
                order := generateRandomOrder()
                if err := sendOrderToKafka(writer, order); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to send order %s: %v", order.OrderUID, err)
                        continue</span>
                }
                <span class="cov0" title="0">log.Printf("Successfully sent order: %s", order.OrderUID)
                time.Sleep(time.Duration(delayMs) * time.Millisecond)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
